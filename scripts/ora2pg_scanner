#!/usr/bin/perl
#------------------------------------------------------------------------------
# Project  : Oracle to Postgresql converter
# Name     : ora2pg_scanner
# Author   : Gilles Darold, gilles _AT_ darold _DOT_ net
# Copyright: Copyright (c) 2000-2025 : Gilles Darold - All rights reserved -
# Function : Script used to scan a list of DSN and generate reports
# Usage    : ora2pg_scanner -l dsn_csv_file -o outdir
#------------------------------------------------------------------------------
#
#        This program is free software: you can redistribute it and/or modify
#        it under the terms of the GNU General Public License as published by
#        the Free Software Foundation, either version 3 of the License, or
#        any later version.
# 
#        This program is distributed in the hope that it will be useful,
#        but WITHOUT ANY WARRANTY; without even the implied warranty of
#        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#        GNU General Public License for more details.
# 
#        You should have received a copy of the GNU General Public License
#        along with this program. If not, see < http://www.gnu.org/licenses/ >.
# 
#------------------------------------------------------------------------------
use strict;

use Getopt::Long qw(:config no_ignore_case bundling);

my $VERSION = '25.0';

my @DB_DSN = ();
my $OUTDIR = '';
my $DRYRUN = 0;
my $INPUT_FILE = '';
my $CONF_FILE = '';
my $HELP = 0;
my $ORA2PG_CMD = 'ora2pg';
my $BINPATH = '';
my $SEP = ($^O =~ /MSWin32|dos/i) ? "\\" : "/";
my $COST_UNIT = 5;
my $FORMAT = 'html';

# Collect command line arguments
GetOptions
(
	'c|config=s'  => \$CONF_FILE,
	'b|binpath=s' => \$BINPATH,
	'f|format=s'  => \$FORMAT,
	'l|list=s'    => \$INPUT_FILE,
	't|test!'     => \$DRYRUN,
        'o|outdir=s'  => \$OUTDIR,
        'u|unit=s'    => \$COST_UNIT,
        'h|help!'     => \$HELP,
);

$OUTDIR = 'output' if (!$OUTDIR);

if (!$INPUT_FILE || !-e $INPUT_FILE || $HELP)
{
	usage();
}

$FORMAT = lc($FORMAT);
if ($FORMAT ne 'html' && $FORMAT ne 'json')
{
	die "致命错误：报告的输出格式必须是 html 或 json\n"; 
}

if ($BINPATH)
{
	$BINPATH =~ s/\Q$SEP\E$//;
	if (-e "$BINPATH$SEP$ORA2PG_CMD")
	{
		$ORA2PG_CMD = "$BINPATH$SEP$ORA2PG_CMD";
	}
	else
	{
		die "致命错误：ora2pg 二进制文件的路径必须存在：$BINPATH$SEP$ORA2PG_CMD\n"; 
	}
}

if ($^O =~ /MSWin32|dos/i)
{
	$ORA2PG_CMD = "perl $ORA2PG_CMD";
}

open(IN, $INPUT_FILE) or die "致命错误：无法读取文件 $INPUT_FILE, $!\n";
while (my $l = <IN>)
{
	#"type","schema/database","dsn","user","password","audit users"
	#"MYSQL","sakila","dbi:mysql:host=192.168.1.10;database=sakila;port=3306","root","mysecret"
	#"ORACLE","HR","dbi:Oracle:host=192.168.1.10;sid=XE;port=1521","system","manager","hr;system;scott"
	#"MSSQL","HR","dbi:ODBC:driver=msodbcsql18;server=srv.database.windows.net;database=testdb","usrname","pwd"
	# skip header line
	chomp($l);
	$l =~ s/\r//;
	next if ($l !~ /^["]*(MYSQL|ORACLE|MSSQL)["]*,/i);
	$l =~ s/"//gs;
	my @data = split(/,/, $l);
	if ($#data < 4)
	{
		 die "致命错误：行中的字段数错误：$l\n";
	}
	my ($type, $schema, $dsn, $user, $passwd, $audit_user) = split(/,/, $l);
	push(@DB_DSN, { (
				'type' => uc($type),
				'schema' => $schema,
				'dsn' => $dsn,
				'user' => $user,
				'pwd' => $passwd,
				'audit_user' => $audit_user,
				'sid' => '',
				'host' => ''
			)
		}
	);
}
close(IN);

# Create the output directory
if (!$DRYRUN)
{
	if (!-d "$OUTDIR")
	{
		mkdir "$OUTDIR";
	}
	else
	{
		print "致命错误：输出目录已存在，$OUTDIR。\n";
		exit 1;
	}
}
else
{
	print "仅通过检索请求的 schema 或数据库来执行连接测试。\n";
}

# Start to generate call to ora2pg
my $header = ' --print_header';
for (my $i = 0; $i < @DB_DSN; $i++)
{
	$header = '' if ($i > 0);
	$ENV{ORA2PG_USER}     = $DB_DSN[$i]->{user};
	$ENV{ORA2PG_PASSWD} = $DB_DSN[$i]->{pwd};
	# Used to pass additional information to ora2pg command
	my $info = '';
	# Set RDBMS type
	$info = ' -m' if ($DB_DSN[$i]->{type} eq 'MYSQL');
	$info = ' -M' if ($DB_DSN[$i]->{type} eq 'MSSQL');
	# Add custom configuration file if set
	$info .= ' -c ' . $CONF_FILE if ($CONF_FILE);
	my $cmd_ora2pg = $ORA2PG_CMD . $info;

	my $audit = '';
	$audit = " --audit_user \"$DB_DSN[$i]->{audit_user}\"" if ($DB_DSN[$i]->{audit_user});
	# Extract SID or db name from the DSN
	# dbi:Oracle:host=foobar;sid=ORCL;port=1521
	# dbi:Oracle:DB
	# dbi:Oracle://192.168.1.10:1521/XE
	# DBI:mysql:database=$db;host=$host
	if ($DB_DSN[$i]->{dsn} =~ m/(?:sid|database|service_name)=([^;]+)/ ||
		$DB_DSN[$i]->{dsn} =~ m/dbi:Oracle:([\w]+)$/  ||
		$DB_DSN[$i]->{dsn} =~ m/dbi:Oracle:\/\/[^\/]+\/([\w]+)/ )
	{
		$DB_DSN[$i]->{sid} = $1;
	}
	elsif (!$DB_DSN[$i]->{schema})
	{
		print "警告：无法为 DSN ". $DB_DSN[$i]->{dsn} ." 确定 sid/数据库名称，没有明确的 schema 无法处理此条目。正在跳过。\n";
		next;
	}
	else
	{
		$DB_DSN[$i]->{sid} = 'schema';
	}

	# Extract host
	if ($DB_DSN[$i]->{dsn} =~ m/(?:host|server)=([^;]+)/ || $DB_DSN[$i]->{dsn} =~ m/dbi:Oracle:\/\/([^\/]+)/)
	{
		$DB_DSN[$i]->{host} = $1;
		$DB_DSN[$i]->{host} =~ s/:\d$+//;
		$DB_DSN[$i]->{host} .= '_';
	}

	# When no schema or database is set, let Ora2Pg autodetect the list of available schema
	if ($DB_DSN[$i]->{schema} eq '')
	{
		if ($DRYRUN)
		{
			print "正在运行： $cmd_ora2pg -t SHOW_SCHEMA -s '$DB_DSN[$i]->{dsn}'\n";
			print `$cmd_ora2pg -t SHOW_SCHEMA -s "$DB_DSN[$i]->{dsn}"`;
			print "对于返回的每个 schema，将执行以下命令：\n";
			print "    $cmd_ora2pg -t SHOW_REPORT --dump_as_sheet --cost_unit_value $COST_UNIT --estimate_cost$header$audit -s \"$DB_DSN[$i]->{dsn}\" -n \"<schema_returned>\" >> $OUTDIR${SEP}dbs_scan.csv\n";
			print "    $cmd_ora2pg -t SHOW_REPORT --dump_as_$FORMAT --cost_unit_value $COST_UNIT --estimate_cost$audit -s \"$DB_DSN[$i]->{dsn}\" -n \"<schema_returned>\" >> \"$OUTDIR${SEP}$DB_DSN[$i]->{host}$DB_DSN[$i]->{sid}_<schema_returned>-report.$FORMAT\"\n";
		}
		else
		{
			my @schema_list = `$cmd_ora2pg -t SHOW_SCHEMA -s "$DB_DSN[$i]->{dsn}"`;
			foreach my $line (@schema_list)
			{
				my ($type, $schemaname) = split(/\s+/, $line);
				$DB_DSN[$i]->{schema} = $schemaname;
				# Escape some chars for file path use
				$schemaname = quotemeta($schemaname);
				print "正在运行： $cmd_ora2pg -t SHOW_REPORT --dump_as_sheet --cost_unit_value $COST_UNIT --estimate_cost$header$audit -s \"$DB_DSN[$i]->{dsn}\" -n \"$DB_DSN[$i]->{schema}\" >> $OUTDIR${SEP}dbs_scan.csv\n";
				`$cmd_ora2pg -t SHOW_REPORT --dump_as_sheet --cost_unit_value $COST_UNIT --estimate_cost$header$audit -s "$DB_DSN[$i]->{dsn}" -n "$DB_DSN[$i]->{schema}" >> $OUTDIR${SEP}dbs_scan.csv`;
				$header = '';

				print "正在运行： $cmd_ora2pg -t SHOW_REPORT --dump_as_$FORMAT --cost_unit_value $COST_UNIT --estimate_cost$audit -s \"$DB_DSN[$i]->{dsn}\" -n \"$DB_DSN[$i]->{schema}\" >> \"$OUTDIR${SEP}$DB_DSN[$i]->{host}$DB_DSN[$i]->{sid}_$schemaname-report.$FORMAT\"\n";
				`$cmd_ora2pg -t SHOW_REPORT --dump_as_$FORMAT --cost_unit_value $COST_UNIT --estimate_cost$audit -s "$DB_DSN[$i]->{dsn}" -n "$DB_DSN[$i]->{schema}" >> "$OUTDIR${SEP}$DB_DSN[$i]->{host}$DB_DSN[$i]->{sid}_$schemaname-report.$FORMAT"`;
			}
		}
	}
	else
	{
		# Escape some chars for file path use
		my $schemaname = quotemeta($DB_DSN[$i]->{schema});

		if ($DRYRUN)
		{
			print "正在运行： $cmd_ora2pg -t SHOW_SCHEMA -s \"$DB_DSN[$i]->{dsn}\" -n \"$DB_DSN[$i]->{schema}\"\n";
			print `$cmd_ora2pg -t SHOW_SCHEMA -s "$DB_DSN[$i]->{dsn}" -n "$DB_DSN[$i]->{schema}"`
		}
		else
		{
			print "正在运行： $cmd_ora2pg -t SHOW_REPORT --dump_as_sheet --cost_unit_value $COST_UNIT --estimate_cost$header$audit -s \"$DB_DSN[$i]->{dsn}\" -n \"$DB_DSN[$i]->{schema}\" >> $OUTDIR${SEP}dbs_scan.csv\n";
			`$cmd_ora2pg -t SHOW_REPORT --dump_as_sheet --cost_unit_value $COST_UNIT --estimate_cost$header$audit -s "$DB_DSN[$i]->{dsn}" -n "$DB_DSN[$i]->{schema}" >> $OUTDIR${SEP}dbs_scan.csv`;
			print "正在运行： $cmd_ora2pg -t SHOW_REPORT --dump_as_$FORMAT --cost_unit_value $COST_UNIT --estimate_cost$audit -s \"$DB_DSN[$i]->{dsn}\" -n \"$DB_DSN[$i]->{schema}\" >> \"$OUTDIR${SEP}$DB_DSN[$i]->{sid}_$schemaname-report.$FORMAT\"\n";
			`$cmd_ora2pg -t SHOW_REPORT --dump_as_$FORMAT --cost_unit_value $COST_UNIT --estimate_cost$audit -s "$DB_DSN[$i]->{dsn}" -n "$DB_DSN[$i]->{schema}" >> "$OUTDIR${SEP}$DB_DSN[$i]->{sid}_$schemaname-report.$FORMAT"`;
		}
	}
}

exit 0;

sub usage
{
	my $msg = shift;

	print "$msg\n" if ($msg); # This is a variable, no translation needed.

	print qq{
用法: ora2pg_scanner -l CSVFILE [-o OUTDIR]

   -b | --binpath DIR: ora2pg 二进制文件所在的目录的完整路径。
		      默认情况下，它将在 PATH 环境变量中搜索。
   -c | --config FILE: 自定义配置文件的路径。
   -d | --dryrun: 只显示将要执行的操作，不实际执行。
   -f | --format TYPE: 报告的输出格式，html 或 json。默认值：html
   -l | --list FILE: 包含要扫描的数据库列表的文件。
		      该文件必须是 CSV 文件，具有以下结构：
		      "type","schema/database","dsn","user","password","audit users"
		      第一列 "type" 必须是 "oracle" 或 "mysql"。
		      第二列是 Oracle 的 schema 或 MySQL 的 database。
		      "audit users" 列是用于审计数据库使用的用户名列表，
		      以逗号分隔。
   -o | --outdir DIR: 报告将存储到的目录的路径。
   -u | --unit MIN : 成本单位值（分钟）。默认值：5 分钟。
		 默认值取自 ora2pg.conf (默认为 5 分钟)。
   -h | --help: 打印此帮助信息并退出。

   以下是一个 CSV 数据库列表文件的完整示例：

	"type","schema/database","dsn","user","password"
	"MYSQL","sakila","dbi:mysql:host=192.168.1.10;database=sakila;port=3306","root","secret"
	"ORACLE","HR","dbi:Oracle:host=192.168.1.10;sid=XE;port=1521","system","manager"
	"MSSQL","HR","dbi:ODBC:driver=msodbcsql18;server=srv.database.windows.net;database=testdb","system","manager"

   CSV 字段分隔符必须是逗号。

   请注意，如果要扫描 Oracle 实例中的所有 schema，只需将 schema 字段留空，
   Ora2Pg 将自动检测所有可用的 schema 并为每个 schema 生成一份报告。
   当然，您需要使用具有足够权限的连接用户才能扫描所有 schema。
   例如：

	"ORACLE","","dbi:Oracle:host=192.168.1.10;sid=XE;port=1521","system","manager"
	"MSSQL","","dbi:ODBC:driver=msodbcsql18;server=srv.database.windows.net;database=testdb","system","manager"

   将为 XE 实例中的所有 schema 生成报告。请注意，在这种情况下，
   ora2pg.conf 中的 SCHEMA 指令不得设置。

};
	exit 1;
}

