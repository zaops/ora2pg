#!/usr/bin/env perl
#------------------------------------------------------------------------------
# Project  : Oracle to Postgresql converter
# Name     : ora2pg
# Author   : Gilles Darold, gilles _AT_ darold _DOT_ net
# Copyright: Copyright (c) 2000-2025 : Gilles Darold - All rights reserved -
# Function : Script used to convert Oracle Database to PostgreSQL
# Usage    : ora2pg configuration_file
#------------------------------------------------------------------------------
#
#        This program is free software: you can redistribute it and/or modify
#        it under the terms of the GNU General Public License as published by
#        the Free Software Foundation, either version 3 of the License, or
#        any later version.
#
#        This program is distributed in the hope that it will be useful,
#        but WITHOUT ANY WARRANTY; without even the implied warranty of
#        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#        GNU General Public License for more details.
#
#        You should have received a copy of the GNU General Public License
#        along with this program. If not, see < http://www.gnu.org/licenses/ >.
#
#------------------------------------------------------------------------------
use strict;
use utf8;
use open ':std', ':encoding(UTF-8)';
use strict qw/vars/;

use Ora2Pg;
use Getopt::Long qw(:config no_ignore_case bundling);
use File::Spec;
use POSIX qw(locale_h sys_wait_h _exit);
setlocale(LC_NUMERIC, '');
setlocale(LC_ALL,     'C');

my $VERSION = $Ora2Pg::VERSION;

$| = 1;

my $CONFIG_FILE = "/etc/ora2pg/ora2pg.conf";
my $FILE_CONF = '';
my $DEBUG = 0;
my $QUIET = 0;
my $HELP = 0;
my $LOGFILE = '';
my $EXPORT_TYPE = '';
my $OUTFILE = '';
my $OUTDIR = '';
my $SHOW_VER = 0;
my $PLSQL = '';
my $DSN = '';
my $DBUSER = '';
my $DBPWD = '';
my $SCHEMA = '';
my $TABLEONLY = '';
my $FORCEOWNER = '';
my $ORA_ENCODING = '';
my $PG_ENCODING = '';
my $INPUT_FILE = '';
my $EXCLUDE = '';
my $ALLOW = '';
my $VIEW_AS_TABLE = '';
my $MVIEW_AS_TABLE = '';
my $ESTIMATE_COST;
my $COST_UNIT_VALUE = 5;
my $DUMP_AS_HTML;
my $DUMP_AS_CSV;
my $DUMP_AS_JSON;
my $DUMP_AS_FILE_PREFIX;
my $DUMP_AS_SHEET;
my $THREAD_COUNT;
my $ORACLE_COPIES;
my $PARALLEL_TABLES;
my $DATA_LIMIT;
my $CREATE_PROJECT = '';
my $PROJECT_BASE = '.';
my $PRINT_HEADER = '';
my $HUMAN_DAY_LIMIT;
my $IS_MYSQL = 0;
my $IS_MSSQL = 0;
my $AUDIT_USER = '';
my $PG_DSN = '';
my $PG_USER = '';
my $PG_PWD = '';
my $COUNT_ROWS = 0;
my $DATA_TYPE = '';
my $GRANT_OBJECT = '';
my $PG_SCHEMA = '';
my $NO_HEADER = 0;
my $ORACLE_SPEED = 0;
my $ORA2PG_SPEED = 0;
my $RELATIVE_PATH = 0;
my $BLOB_TO_LO = 0;
my $IMPORT_LO = 0;
my @WHERE_CLAUSE = ();
my @DELETE_CLAUSE = ();
my $START_SCN = '';
my $CDC_READY = '';
my $CDC_FILE = 'TABLES_SCN.log';
my $DROP_IF_EXISTS = 0;
my $ORACLE_FDW_PREFETCH;
my $NO_START_SCN = 0;
my $NO_CLEAN_COMMENT = 0;

my @SCHEMA_ARRAY  = qw( SEQUENCE SEQUENCE_VALUES TABLE PACKAGE VIEW GRANT TRIGGER FUNCTION PROCEDURE TABLESPACE PARTITION TYPE MVIEW DBLINK SYNONYM DIRECTORY );
my @EXTERNAL_ARRAY  = qw( KETTLE FDW );
my @REPORT_ARRAY  = qw( SHOW_VERSION SHOW_REPORT SHOW_SCHEMA SHOW_TABLE SHOW_COLUMN SHOW_ENCODING  );
my @TEST_ARRAY  = qw( TEST TEST_COUNT TEST_VIEW TEST_DATA);
my @SOURCES_ARRAY = qw( PACKAGE VIEW TRIGGER FUNCTION PROCEDURE PARTITION TYPE MVIEW );
my @DATA_ARRAY    = qw( INSERT COPY);
my @CAPABILITIES  = qw( QUERY LOAD SCRIPT );

my @MYSQL_SCHEMA_ARRAY  = qw( TABLE VIEW GRANT TRIGGER FUNCTION PROCEDURE PARTITION DBLINK );
my @MYSQL_SOURCES_ARRAY = qw( VIEW TRIGGER FUNCTION PROCEDURE PARTITION );

my @MSSQL_SCHEMA_ARRAY  = qw( SEQUENCE SEQUENCE_VALUES TABLE PACKAGE VIEW GRANT TRIGGER FUNCTION PROCEDURE TABLESPACE PARTITION TYPE MVIEW DBLINK SYNONYM DIRECTORY );
my @MSSQL_SOURCES_ARRAY = qw( PACKAGE VIEW TRIGGER FUNCTION PROCEDURE PARTITION TYPE MVIEW );

my @GRANT_OBJECTS_ARRAY = ('USER','TABLE','VIEW','MATERIALIZED VIEW','SEQUENCE','PROCEDURE','FUNCTION','PACKAGE BODY','TYPE','SYNONYM','DIRECTORY');

my $TMP_DIR      = File::Spec->tmpdir() || '/tmp';

my @OPTIONS = ();

# Collect command line arguments
GetOptions (
	'a|allow=s' => \$ALLOW,
        'b|basedir=s' => \$OUTDIR,
        'c|conf=s' => \$FILE_CONF,
        'C|cdc_file=s' => \$CDC_FILE,
        'd|debug!' => \$DEBUG,
        'D|data_type=s' => \$DATA_TYPE,
	'e|exclude=s' => \$EXCLUDE,
	'g|grant_object=s' => \$GRANT_OBJECT,
        'h|help!' => \$HELP,
	'i|input_file=s' => \$INPUT_FILE,
	'j|jobs=i' => \$THREAD_COUNT,
	'J|copies=i' => \$ORACLE_COPIES,
        'l|log=s' => \$LOGFILE,
	'L|limit=i' => \$DATA_LIMIT,
	'm|mysql!' => \$IS_MYSQL,
	'M|mssql!' => \$IS_MSSQL,
	'n|namespace=s' => \$SCHEMA,
	'N|pg_schema=s' => \$PG_SCHEMA,
        'o|out=s' => \$OUTFILE,
        'O|option=s' => \@OPTIONS,
	'p|plsql!' => \$PLSQL,
	'P|parallel=i' =>\$PARALLEL_TABLES,
	'q|quiet!' => \$QUIET,
	'r|relative!' => \$RELATIVE_PATH,
	's|source=s' => \$DSN,
	'S|scn=s' => \$START_SCN,
        't|type=s' => \$EXPORT_TYPE,
        'T|temp_dir=s' => \$TMP_DIR,
	'u|user=s' => \$DBUSER,
	'v|version!' => \$SHOW_VER,
	'w|password=s' => \$DBPWD,
	'W|where=s' => \@WHERE_CLAUSE,
	'x|xtable=s' => \$TABLEONLY, # Obsolete
	'forceowner=s' => \$FORCEOWNER,
	'nls_lang=s' => \$ORA_ENCODING,
	'client_encoding=s' => \$PG_ENCODING,
	'view_as_table=s' => \$VIEW_AS_TABLE,
	'mview_as_table=s' => \$MVIEW_AS_TABLE,
	'estimate_cost!' =>\$ESTIMATE_COST,
	'cost_unit_value=i' =>\$COST_UNIT_VALUE,
	'dump_as_html!' =>\$DUMP_AS_HTML,
	'dump_as_csv!' =>\$DUMP_AS_CSV,
	'dump_as_json!' =>\$DUMP_AS_JSON,
	'dump_as_sheet!' =>\$DUMP_AS_SHEET,
	'dump_as_file_prefix=s' =>\$DUMP_AS_FILE_PREFIX,
	'init_project=s' => \$CREATE_PROJECT,
	'project_base=s' => \$PROJECT_BASE,
	'print_header!' => \$PRINT_HEADER,
	'human_days_limit=i' => \$HUMAN_DAY_LIMIT,
	'audit_user=s' => \$AUDIT_USER,
	'pg_dsn=s' => \$PG_DSN,
	'pg_user=s' => \$PG_USER,
	'pg_pwd=s' => \$PG_PWD,
	'count_rows!' => \$COUNT_ROWS,
	'no_header!' => \$NO_HEADER,
	'oracle_speed!' => \$ORACLE_SPEED,
	'ora2pg_speed!' => \$ORA2PG_SPEED,
	'blob_to_lo!' => \$BLOB_TO_LO,
	'cdc_ready!' => \$CDC_READY,
	'lo_import!' => \$IMPORT_LO,
	'drop_if_exists!' => \$DROP_IF_EXISTS,
	'delete=s' => \@DELETE_CLAUSE,
	'oracle_fdw_prefetch=i' => \$ORACLE_FDW_PREFETCH,
	'no_start_scn!' => \$NO_START_SCN,
	'no_clean_comment!' => \$NO_CLEAN_COMMENT,
);

# Check command line parameters
if ($SHOW_VER)
{
	print "Ora2Pg v$VERSION\n";
	exit 0;
}
if ($HELP) {
	&usage();
}

if ($IS_MYSQL)
{
	@SCHEMA_ARRAY = @MYSQL_SCHEMA_ARRAY;
	@SOURCES_ARRAY = @MYSQL_SOURCES_ARRAY;
	@EXTERNAL_ARRAY = ();
} elsif ($IS_MSSQL)
{
	@SCHEMA_ARRAY = @MSSQL_SCHEMA_ARRAY;
	@SOURCES_ARRAY = @MSSQL_SOURCES_ARRAY;
	@EXTERNAL_ARRAY = ();
}

# Create project repository and useful stuff
if ($CREATE_PROJECT)
{
	if (!-d "$PROJECT_BASE")
	{
		print "错误：项目基础目录不存在：$PROJECT_BASE\n";
		&usage();
	}
	print STDERR "创建项目 $CREATE_PROJECT\n";
	&create_project($CREATE_PROJECT, $PROJECT_BASE);
	exit 0;
}

if ($GRANT_OBJECT && !grep(/^$GRANT_OBJECT$/, @GRANT_OBJECTS_ARRAY))
{
	print "错误：-g 选项中的权限对象类型无效。请参考 GRANT_OBJECT 配置指令\n";
	exit 1;
}

# Clean temporary files
unless(opendir(DIR, "$TMP_DIR"))
{
	print "错误：无法打开目录 $TMP_DIR: $!\n";
	exit 1;
}
my @files = grep { $_ =~ /^tmp_ora2pg.*$/ } readdir(DIR);
closedir DIR;
foreach (@files)
{
	if (-e "$TMP_DIR/$_" and not unlink("$TMP_DIR/$_"))
	{
		print "错误：无法删除临时文件 $TMP_DIR/$_\n";
		exit 1;
	}
}

# Check configuration file
my $GOES_WITH_DEFAULT = 0;
if ($FILE_CONF && ! -e $FILE_CONF)
{
	print "错误：找不到配置文件 $FILE_CONF\n";
	&usage();
}
elsif (!$FILE_CONF && ! -e $CONFIG_FILE)
{
	# At least we need configuration to connect to Oracle
	if (!$DSN || (!$DBUSER && !$ENV{ORA2PG_USER}) || (!$DBPWD && !$ENV{ORA2PG_PASSWD}))
	{
		print "错误：找不到配置文件 $CONFIG_FILE\n";
		&usage();
	}
	$CONFIG_FILE = '';
	$GOES_WITH_DEFAULT = 1;
}

push(@CAPABILITIES, @SCHEMA_ARRAY, @REPORT_ARRAY, @DATA_ARRAY, @EXTERNAL_ARRAY, @TEST_ARRAY);

# Validate export type
$EXPORT_TYPE = uc($EXPORT_TYPE);
$EXPORT_TYPE =~ s/^DATA$/COPY/;
foreach my $t (split(/[,;\s\t]+/, $EXPORT_TYPE))
{
	if ($t && !grep(/^$t$/, @CAPABILITIES))
	{
		print "错误：未知的导出类型: $t. 支持的类型: ", join(',', @CAPABILITIES), "\n";
		&usage();
	}
}

# Preserve barckward compatibility
if ($TABLEONLY)
{
	warn "警告：-x | --xtable 已废弃，请使用 -a | --allow 选项\n";
	if (!$ALLOW) {
		$ALLOW = $TABLEONLY;
	}
}

if ($BLOB_TO_LO && !$CREATE_PROJECT && !grep(/^$EXPORT_TYPE$/, 'TABLE', 'INSERT', 'SHOW_COLUMN'))
{
	print "错误：--blob_to_lo 选项只能与 INSERT 操作一起使用\n";
	&usage();
}

sub getout
{
        my $sig = shift;
        print STDERR "Received terminating signal ($sig).\n";
        $SIG{INT} = \&getout;
        $SIG{TERM} = \&getout;

	# Cleaning temporary files
	unless(opendir(DIR, "$TMP_DIR"))
	{
		print "致命错误：无法打开目录 $TMP_DIR: $!\n";
		exit 1;
	}
	my @files = grep { $_ =~ /^tmp_ora2pg.*$/ } readdir(DIR);
	closedir DIR;
	foreach (@files) {
		unlink("$TMP_DIR/$_\n");
	}

	exit 1;
}
$SIG{INT} = \&getout;
$SIG{TERM} = \&getout;

# Replace ; or space by comma in the user list
$AUDIT_USER =~ s/[;\s]+/,/g;

# Look if the ALLOW and EXCLUDE values are existing files,
# in this case import the content as a space separated list.
if (-e $ALLOW)
{
	my $fh = new IO::File;
	$fh->open($ALLOW) or die "致命错误：无法读取文件 $ALLOW, $!\n";
	$ALLOW = '';
	while (my $l = <$fh>)
	{
		chomp($l);
		$ALLOW .= "$l ";
	}
	$fh->close;
	$ALLOW =~ s/ $//;
}

if (-e $EXCLUDE)
{
	my $fh = new IO::File;
	$fh->open($EXCLUDE) or die "致命错误：无法读取文件 $EXCLUDE, $!\n";
	$EXCLUDE = '';
	while (my $l = <$fh>)
	{
		chomp($l);
		$EXCLUDE .= "$l ";
	}
	$fh->close;
	$EXCLUDE =~ s/ $//;
}

# Create an instance of the Ora2Pg perl module
my $schema = new Ora2Pg (
	config => $FILE_CONF || $CONFIG_FILE,
	type   => $EXPORT_TYPE,
	debug  => $DEBUG,
	logfile=> $LOGFILE,
	output => $OUTFILE,
	output_dir => $OUTDIR,
	plsql_pgsql => $PLSQL,
	datasource => $DSN,
        user => $DBUSER || $ENV{ORA2PG_USER},
        password => $DBPWD || $ENV{ORA2PG_PASSWD},
	schema => $SCHEMA,
	pg_schema => $PG_SCHEMA,
	force_owner => $FORCEOWNER,
        nls_lang => $ORA_ENCODING,
        client_encoding => $PG_ENCODING,
        input_file => $INPUT_FILE,
	quiet => $QUIET,
	exclude => $EXCLUDE,
	allow => $ALLOW,
	view_as_table => $VIEW_AS_TABLE,
	mview_as_table => $MVIEW_AS_TABLE,
	estimate_cost => $ESTIMATE_COST,
	cost_unit_value => $COST_UNIT_VALUE,
	dump_as_html => $DUMP_AS_HTML,
	dump_as_csv => $DUMP_AS_CSV,
	dump_as_json => $DUMP_AS_JSON,
	dump_as_sheet => $DUMP_AS_SHEET,
	dump_as_file_prefix => $DUMP_AS_FILE_PREFIX,
	thread_count => $THREAD_COUNT,
	oracle_copies => $ORACLE_COPIES,
	data_limit => $DATA_LIMIT,
	parallel_tables => $PARALLEL_TABLES,
	print_header => $PRINT_HEADER,
	human_days_limit => $HUMAN_DAY_LIMIT,
	is_mysql => $IS_MYSQL,
	is_mssql => $IS_MSSQL,
	audit_user => $AUDIT_USER,
	temp_dir => $TMP_DIR,
	pg_dsn => $PG_DSN,
	pg_user => $PG_USER,
	pg_pwd => $PG_PWD,
	count_rows => $COUNT_ROWS,
	data_type => $DATA_TYPE,
	grant_object => $GRANT_OBJECT,
	no_header => $NO_HEADER,
	oracle_speed => $ORACLE_SPEED,
	ora2pg_speed => $ORA2PG_SPEED,
	psql_relative_path => $RELATIVE_PATH,
	where => join(' ', @WHERE_CLAUSE),
	blob_to_lo => $BLOB_TO_LO,
	start_scn => $START_SCN,
	cdc_ready => $CDC_READY,
	lo_import => $IMPORT_LO,
	cdc_file => $CDC_FILE,
	drop_if_exists => $DROP_IF_EXISTS,
	delete => join(' ', @DELETE_CLAUSE),
        oracle_fdw_prefetch => $ORACLE_FDW_PREFETCH,
	no_start_scn => $NO_START_SCN,
	options => join('|', @OPTIONS),
	no_clean_comment => $NO_CLEAN_COMMENT,
);

# Look at configuration file if an input file is defined
if (!$INPUT_FILE && !$GOES_WITH_DEFAULT)
{
	my $cf_file = $FILE_CONF || $CONFIG_FILE;
	my $fh = new IO::File;
	$fh->open($cf_file) or die "致命错误：无法读取配置文件 $cf_file, $!\n";
	while (my $l = <$fh>)
	{
		chomp($l);
		$l =~ s/\r//gs;
		$l =~ s/^\s*\#.*$//g;
		next if (!$l || ($l =~ /^\s+$/));
		$l =~ s/^\s*//; $l =~ s/\s*$//;
		my ($var, $val) = split(/\s+/, $l, 2);
		$var = uc($var);
		if ($var eq 'INPUT_FILE' && $val) {
			$INPUT_FILE = $val;
		}
	}
	$fh->close();
}

# Proceed to Oracle DB extraction following
# configuration file definitions.
if ( ($EXPORT_TYPE !~ /^SHOW_/i) && !$INPUT_FILE ) {
	$schema->export_schema();
}

# Check if error occurs during data export
unless(opendir(DIR, "$TMP_DIR"))
{
	print "致命错误：无法打开目录 $TMP_DIR: $!\n";
	exit 1;
}
@files = grep { $_ =~ /^tmp_ora2pg.*$/ } readdir(DIR);
closedir DIR;
if ($#files >= 0)
{
	print STDERR "\nWARNING: an error occurs during data export. Please check what's happen.\n\n";
	exit 2;
}

exit(0);

####
# Show usage
####
sub usage
{
	print qq{
用法: ora2pg [-dhpqv --estimate_cost --dump_as_html] [--option value]

    -a | --allow str  : 允许导出的对象列表，用逗号分隔。
                        也可与 SHOW_COLUMN 一起使用。
    -b | --basedir dir: 设置默认输出目录，导出文件将存储在此处。
    -c | --conf file  : 设置替代配置文件，而不是默认的
                        /etc/ora2pg/ora2pg.conf。
    -C | --cdc_file file: 导出期间用于存储/读取每个表 SCN 的文件。
                        默认：当前目录中的 TABLES_SCN.log。这是
                        --cdc_ready 选项写入的文件。
    -d | --debug      : 启用详细输出。
    -D | --data_type str : 允许在命令行进行自定义类型替换。
    -e | --exclude str: 从导出中排除的对象列表，用逗号分隔。
                        也可与 SHOW_COLUMN 一起使用。
    -h | --help       : 打印此简短帮助。
    -g | --grant_object type : 从给定对象类型提取权限。
                        请参考 GRANT_OBJECT 配置的可能值
    -i | --input file : 包含要转换的 Oracle PL/SQL 代码的文件，
                        无需启动 Oracle 数据库连接。
    -j | --jobs num   : 向 PostgreSQL 发送数据的并行进程数。
    -J | --copies num : 从 Oracle 提取数据的并行连接数。
    -l | --log file   : 设置日志文件。默认为 stdout。
    -L | --limit num  : 从 Oracle 提取并存储在内存中的元组数，
                        然后写入，默认：10000。
    -m | --mysql      : 导出 MySQL 数据库而不是 Oracle 模式。
    -M | --mssql      : 导出 Microsoft SQL Server 数据库。
    -n | --namespace schema : 设置要提取的 Oracle 模式。
    -N | --pg_schema schema : 设置 PostgreSQL 的 search_path。
    -o | --out file   : 设置输出文件路径，SQL 将写入该文件
                        默认：当前目录中的 output.sql
    -O | --options    : 覆盖任何配置参数，可多次使用
                        语法：-O "PARAM_NAME=value"
    -p | --plsql      : 启用 PL/SQL 到 PL/pgSQL 代码转换
    -P | --parallel num: 同时提取的并行表数量
    -q | --quiet      : 禁用进度条
    -r | --relative   : 在生成的 psql 脚本中使用 \\ir 而不是 \\i
    -s | --source DSN : 设置 Oracle DBI 数据源
    -S | --scn    SCN : 设置用于导出数据的 Oracle 系统更改号 (SCN)
                        将在 WHERE 子句中使用以获取数据
                        与 COPY 或 INSERT 操作一起使用
    -t | --type export: 设置导出类型，覆盖配置文件中的 TYPE 设置
    -T | --temp_dir dir: 当多个 ora2pg 并行运行时设置不同的临时目录
    -u | --user name  : 设置 Oracle 数据库连接用户
                        可使用 ORA2PG_USER 环境变量代替
    -v | --version    : 显示 Ora2Pg 版本并退出
    -w | --password pwd : 设置 Oracle 数据库用户密码
                        可使用 ORA2PG_PASSWD 环境变量代替
    -W | --where clause : 设置应用于 Oracle 查询的 WHERE 子句以检索数据
                        可多次使用
    --forceowner      : 强制 ora2pg 设置表和序列所有者与 Oracle 数据库中相同
                  如果值设为用户名，则使用该用户名作为对象所有者
                  默认情况下，连接 PostgreSQL 数据库的用户将是所有者
    --nls_lang code: 设置 Oracle NLS_LANG 客户端编码
    --client_encoding code: 设置 PostgreSQL 客户端编码
    --view_as_table str: 要作为表导出的视图列表，逗号分隔
    --estimate_cost   : 与 SHOW_REPORT 一起使用激活迁移成本评估
    --cost_unit_value minutes: 成本评估单位的分钟数
                  默认：5 分钟，对应 PostgreSQL 专家进行的迁移
                  如果是首次迁移，建议设置为 10
   --dump_as_html     : 强制 ora2pg 以 HTML 格式输出报告，仅与
                        SHOW_REPORT 一起使用。默认为纯文本格式
   --dump_as_csv      : 同上，但强制 ora2pg 以 CSV 格式输出报告
   --dump_as_json     : 同上，但强制 ora2pg 以 JSON 格式输出报告
   --dump_as_sheet    : 每个数据库一行的 CSV 迁移评估报告
   --dump_as_file_prefix : 文件名前缀，后缀将根据选择的 dump_as_* 开关添加，
                           后缀将是 .html、.csv、.json。
   --init_project name: 初始化典型的 ora2pg 项目树。顶级目录
                        将在项目基础目录下创建。
   --project_base dir : 定义 ora2pg 项目树的基础目录。默认为当前目录。
   --print_header     : 与 --dump_as_sheet 一起使用以打印 CSV 标题，
                        特别是在 ora2pg 的第一次运行时。
   --human_days_limit num : 设置人天限制数，迁移评估级别从 B 切换到 C。
                        默认设置为 5 人天。
   --audit_user list  : 用逗号分隔的用户名列表，用于过滤 DBA_AUDIT_TRAIL 表中的查询。
                        仅与 SHOW_REPORT 和 QUERY 导出类型一起使用。
   --pg_dsn DSN       : 设置 PostgreSQL 的数据源以进行直接导入。
   --pg_user name     : 设置要使用的 PostgreSQL 用户。
   --pg_pwd password  : 设置要使用的 PostgreSQL 密码。
   --count_rows       : 强制 ora2pg 在 TEST、TEST_COUNT 和 SHOW_TABLE 操作中
                        执行真实的行计数。
   --no_header        : 不向输出文件追加 Ora2Pg 标题
   --oracle_speed     : 用于了解 Oracle 能够发送数据的速度。
                        不会处理或写入任何数据。
   --ora2pg_speed     : 用于了解 Ora2Pg 能够发送转换数据的速度。
                        不会写入任何内容。
   --blob_to_lo       : 将 BLOB 导出为大对象，只能与
                        SHOW_COLUMN、TABLE 和 INSERT 操作一起使用。
   --cdc_ready        : 使用当前 SCN 每个表导出数据并将其注册到
                        默认名为 TABLES_SCN.log 的文件中。
                        可以使用 -C | --cdc_file 更改。
   --lo_import        : 使用 psql \\lo_import 命令将 BLOB 导入为大对象。
                        可用于使用 COPY 导入数据并在第二次传递中手动导入大对象。
                        对于 > 1GB 的 BLOB 是必需的。更多说明请参考文档
   --mview_as_table str: 要作为常规表导出的物化视图列表，用逗号分隔。
   --drop_if_exists   : 如果对象存在，则在创建之前删除它。
   --delete clause    : 设置要应用于 Oracle 查询的 DELETE 子句，
                        在导入数据之前应用。可以多次使用。
   --oracle_fdw_prefetch: 设置 oracle_fdw 预取值。较大的值
                        通常会以目标处更大的内存利用率为代价
                        实现更快的数据传输。
    --no_start_scn    : 强制 Ora2Pg 不使用 SCN 导出数据。默认情况下，
    			当前 SCN 用于从所有表导出数据。
    --no_clean_comment: 在解析之前不要尝试删除源文件中的注释。
                        在某些情况下，这可能需要很长时间。

请访问 https://ora2pg.darold.net/ 查看完整文档获取更多帮助，
或使用 'man ora2pg' 查看手册页

ora2pg 成功时返回 0，错误时返回 1。当子进程被中断并收到警告消息时返回 2：
    "WARNING: an error occurs during data export. Please check what's happen."
大多数情况下这是内存不足问题，请尝试减少 DATA_LIMIT 值

};
	exit 1;

}

####
# Create a generic project tree
####
sub create_project
{
	my ($create_project, $project_base) = @_;

	# Look at default configuration file to use
	my $conf_file = $CONFIG_FILE . '.dist';
	if ($FILE_CONF) {
		# Use file given in parameter
		$conf_file = $FILE_CONF;
	}
	if (!-f $conf_file || -z $conf_file) {
		print "错误：文件 $conf_file 不存在\n";
		exit 1;
	}
	# Build entire project tree
	my $base_path = $project_base . '/' . $create_project;
	if (-e $base_path) {
		print "错误：项目目录已存在 $base_path\n";
		exit 1;
	}
	mkdir("$base_path");
	print "$base_path/\n";
	mkdir("$base_path/schema");
	print "\tschema/\n";

	foreach my $exp (sort @SCHEMA_ARRAY ) {
		my $tpath = lc($exp);
		$tpath =~ s/y$/ie/;
		if ($exp ne 'SEQUENCE_VALUES') {
			mkdir("$base_path/schema/" . $tpath . 's');
			print "\t\t" . $tpath . "s/\n";
		} else {
			mkdir("$base_path/schema/" . $tpath);
			print "\t\t" . $tpath . "/\n";
		}
	}
	mkdir("$base_path/sources");
	print "\tsources/\n";
	foreach my $exp (sort @SOURCES_ARRAY ) {
		my $tpath = lc($exp);
		$tpath =~ s/y$/ie/;
		mkdir("$base_path/sources/" . $tpath . 's');
		print "\t\t" . $tpath . "s/\n";
	}
	mkdir("$base_path/data");
	print "\tdata/\n";
	mkdir("$base_path/config");
	print "\tconfig/\n";
	mkdir("$base_path/reports");
	print "\treports/\n";
	print "\n";

	# Copy configuration file and transform it as a generic one
	print "生成通用配置文件\n";
	if (open(IN, "$conf_file")) {
		my @cf = <IN>;
		close(IN);
		# Create a generic configuration file only if it has the .dist extension
		# otherwise use the configuration given at command line (-c option)
		if ($conf_file =~ /\.dist/) {
			&make_config_generic(\@cf);
		}
		unless(open(OUT, ">$base_path/config/ora2pg.conf")) {
			print "错误：无法写入文件 $base_path/config/ora2pg.conf\n";
			exit 1;
		}
		print OUT @cf;
		close(OUT);
	} else {
		print "错误：无法读取文件 $conf_file, $!\n";
		exit 1;
	}

	# Generate shell script to execute all export
	print "创建脚本 export_schema.sh 以自动化所有导出\n";
	unless(open(OUT, "> $base_path/export_schema.sh")) {
		print "错误：无法写入文件 $base_path/export_schema.sh\n";
		exit 1;
	}
	my $ablob_to_lo = '';
	my $data_action = 'COPY';
	if ($BLOB_TO_LO)
	{
		$ablob_to_lo = '--blob_to_lo';
		$data_action = 'INSERT';
	}
	print OUT qq{#!/bin/sh
#-------------------------------------------------------------------------------
#
# Generated by Ora2Pg, the Oracle database Schema converter, version $VERSION
#
#-------------------------------------------------------------------------------
};
	print OUT "EXPORT_TYPE=\"", join(' ', @SCHEMA_ARRAY), "\"\n";
	print OUT "SOURCE_TYPE=\"", join(' ', @SOURCES_ARRAY), "\"\n";
	print OUT "namespace=\".\"\n";
	print OUT "unit_cost=$COST_UNIT_VALUE\n";
	print OUT qq{
ora2pg -t SHOW_TABLE -c \$namespace/config/ora2pg.conf > \$namespace/reports/tables.txt
ora2pg -t SHOW_COLUMN -c \$namespace/config/ora2pg.conf $ablob_to_lo > \$namespace/reports/columns.txt
ora2pg -t SHOW_REPORT -c \$namespace/config/ora2pg.conf --dump_as_html --cost_unit_value  \$unit_cost --estimate_cost > \$namespace/reports/report.html

for etype in \$(echo \$EXPORT_TYPE | tr " " "\\n")
do
        ltype=`echo \$etype | tr '[:upper:]' '[:lower:]'`
        ltype=`echo \$ltype | sed 's/y\$/ie/'`
        ltype=`echo \$ltype | sed 's/s\$//'`
	if [ "\$etype" = "TABLE" ]; then
		blob_to_lo="$ablob_to_lo"
	else
		blob_to_lo=""
	fi
        echo "Running: ora2pg -p -t \$etype -o \$ltype.sql -b \$namespace/schema/\$\{ltype\}s -c \$namespace/config/ora2pg.conf \$\{blob_to_lo\}"
        ora2pg -p -t \$etype -o \$ltype.sql -b \$namespace/schema/\$\{ltype\}s -c \$namespace/config/ora2pg.conf \$\{blob_to_lo\}
	ret=`grep "Nothing found" \$namespace/schema/\$\{ltype\}s/\$ltype.sql 2> /dev/null`
	if [ ! -z "\$ret" ]; then
		rm \$namespace/schema/\$\{ltype\}s/\$ltype.sql
	fi
done

for etype in \$(echo \$SOURCE_TYPE | tr " " "\\n")
do
        ltype=`echo \$etype | tr '[:upper:]' '[:lower:]'`
        ltype=`echo \$ltype | sed 's/y\$/ie/'`
        echo "Running: ora2pg -t \$etype -o \$ltype.sql -b \$namespace/sources/\$\{ltype\}s -c \$namespace/config/ora2pg.conf"
        ora2pg -t \$etype -o \$ltype.sql -b \$namespace/sources/\$\{ltype\}s -c \$namespace/config/ora2pg.conf
	ret=`grep "Nothing found" \$namespace/sources/\$\{ltype\}s/\$ltype.sql 2> /dev/null`
	if [ ! -z "\$ret" ]; then
		rm \$namespace/sources/\$\{ltype\}s/\$ltype.sql
	fi
done

echo
echo
echo "To extract data use the following command:"
echo
echo "ora2pg -t $data_action -o data.sql -b \$namespace/data -c \$namespace/config/ora2pg.conf $ablob_to_lo"
echo

exit 0
};
	close(OUT);
	chmod(0700, "$base_path/export_schema.sh");
 
	# On Windows system generate a Powershell script to execute all export
	if ($^O =~ /MSWin32|dos/i)
	{
		print "创建 PowerShell 脚本 export_schema.ps1 以自动化所有导出\n";
		unless(open(OUT, "> $base_path/export_schema.ps1")) {
			print "错误：无法写入文件 $base_path/export_schema.ps1\n";
			exit 1;
		}
		print OUT qq{
#-------------------------------------------------------------------------------
#
# Generated by Ora2Pg, the Oracle database Schema converter, version $VERSION
#
#-------------------------------------------------------------------------------
};

		print OUT "\$EXPORT_TYPE=", join(',', map "'$_'",@SCHEMA_ARRAY),"\n";
		print OUT "\$SOURCE_TYPE=", join(',', map "'$_'",@SOURCES_ARRAY), "\n";
		print OUT  "\$namespace=\".\"\n";
		print OUT  "\$unit_cost=$COST_UNIT_VALUE\n"; 

		print OUT  qq{ 
ora2pg -t SHOW_TABLE -c \$namespace/config/ora2pg.conf > \$namespace/reports/tables.txt
ora2pg -t SHOW_COLUMN -c \$namespace/config/ora2pg.conf $ablob_to_lo > \$namespace/reports/columns.txt
ora2pg -t SHOW_REPORT -c \$namespace/config/ora2pg.conf --dump_as_html --cost_unit_value  \$unit_cost --estimate_cost \> \$namespace/reports/report.html

foreach (\$etype in \$EXPORT_TYPE)
{
	\$ltype =  \$etype.ToLower() -replace 'y\$', 'ie'  
	\$ltype =  \$etype.ToLower() -replace 's\$', ''
	if ( "\$etype" -eq "TABLE" )
	{
		blob_to_lo="$ablob_to_lo"
	}
	else
	{
		blob_to_lo=""
	}
	\$cmd="ora2pg -p -t \$etype -o \$ltype.sql -b \$namespace/schema/\${ltype}s -c \$namespace/config/ora2pg.conf \$\{blob_to_lo\}"  
	Write-Host  "Running: \$cmd"
	Invoke-Expression \$cmd
	Select-String -Pattern 'Nothing found' -Path \$namespace/schema/\${ltype}s/\$ltype.sql -List |Remove-Item   
     
}

foreach (\$etype in \$SOURCE_TYPE)
{     
	\$ltype =  \$etype.ToLower() -replace 'y\$', 'ie'
	\$cmd="ora2pg -t \$etype -o \$ltype.sql -b \$namespace/sources/\${ltype}s -c \$namespace/config/ora2pg.conf"
	write-host    "Running: \$cmd"
	Invoke-Expression \$cmd 
	Select-String -Pattern 'Nothing found' -Path \$namespace/sources/\${ltype}s/\$ltype.sql -List |Remove-Item 
} 
 
Write-Host
Write-Host
Write-Host "To extract data use the following command:"
Write-Host
Write-Host "ora2pg -t $data_action -o data.sql -b \$namespace/data -c \$namespace/config/ora2pg.conf $ablob_to_lo"
Write-Host
exit 0;
};
	}
	close(OUT);

	# Generate shell script to execute all import
	print "创建脚本 import_all.sh 以自动化所有导入\n";
	my $exportype = "EXPORT_TYPE=\"TYPE " . join(' ', grep( !/^TYPE$/, @SCHEMA_ARRAY)) . "\"\n";
	unless(open(OUT, "> $base_path/import_all.sh")) {
		print "错误：无法写入文件 $base_path/import_all.sh\n";
		exit 1;
	}

	$ablob_to_lo = '';
	$data_action = 'COPY';
	if ($BLOB_TO_LO)
	{
		$ablob_to_lo = '--blob_to_lo';
		$data_action = 'INSERT';
	}
	while (my $l = <DATA>) {
		$l =~ s/^EXPORT_TYPE=.*/$exportype/s;
		$l =~ s/ORA2PG_VERSION/$VERSION/s;
		$l =~ s/DATA_ACTION/$data_action/s;
		$l =~ s/BLOB2LO/$ablob_to_lo/s;
		print OUT $l;
	}
	close(OUT);
	chmod(0700, "$base_path/import_all.sh");
}

####
# Set a generic configuration
####
sub make_config_generic
{
	my $conf_arr = shift;

	chomp(@$conf_arr);

	my $schema = 'CHANGE_THIS_SCHEMA_NAME';
	$schema = $SCHEMA if ($SCHEMA);
	for (my $i = 0; $i <= $#{$conf_arr}; $i++) {
		if ($IS_MYSQL) {
			$conf_arr->[$i] =~ s/^# Set Oracle database/# Set MySQL database/;
			$conf_arr->[$i] =~ s/^(ORACLE_DSN.*dbi):Oracle:(.*);sid=SIDNAME/$1:mysql:$2;database=dbname/;
			$conf_arr->[$i] =~ s/CHANGE_THIS_SCHEMA_NAME/CHANGE_THIS_DB_NAME/;
			$conf_arr->[$i] =~ s/#REPLACE_ZERO_DATE.*/REPLACE_ZERO_DATE\t-INFINITY/;
		} elsif ($IS_MSSQL) {
			$conf_arr->[$i] =~ s/^# Set Oracle database/# Set MSSQL database/;
			$conf_arr->[$i] =~ s/^(ORACLE_DSN.*dbi):Oracle:(.*);sid=SIDNAME/$1:ODBC:driver=msodbcsql18;$2;database=dbname/;
			$conf_arr->[$i] =~ s/;host=/;server=/;
			$conf_arr->[$i] =~ s/;port=1521/;port=1433;TrustCertificate=yes;TrustServerCertificate=Yes/;
		} elsif ($ENV{ORACLE_HOME}) {
			$conf_arr->[$i] =~ s/^ORACLE_HOME.*/ORACLE_HOME\t$ENV{ORACLE_HOME}/;
		}
		$conf_arr->[$i] =~ s/^USER_GRANTS.*0/USER_GRANTS\t1/;
		$conf_arr->[$i] =~ s/^#SCHEMA.*SCHEMA_NAME/SCHEMA\t$schema/;
		$conf_arr->[$i] =~ s/^(BINMODE.*)/#$1/;
		$conf_arr->[$i] =~ s/^PLSQL_PGSQL.*1/PLSQL_PGSQL\t0/;
		$conf_arr->[$i] =~ s/^FILE_PER_CONSTRAINT.*0/FILE_PER_CONSTRAINT\t1/;
		$conf_arr->[$i] =~ s/^FILE_PER_INDEX.*0/FILE_PER_INDEX\t1/;
		$conf_arr->[$i] =~ s/^FILE_PER_FKEYS.*0/FILE_PER_FKEYS\t1/;
		$conf_arr->[$i] =~ s/^FILE_PER_TABLE.*0/FILE_PER_TABLE\t1/;
		$conf_arr->[$i] =~ s/^FILE_PER_FUNCTION.*0/FILE_PER_FUNCTION\t1/;
		$conf_arr->[$i] =~ s/^TRUNCATE_TABLE.*0/TRUNCATE_TABLE\t1/;
		$conf_arr->[$i] =~ s/^DISABLE_SEQUENCE.*0/DISABLE_SEQUENCE\t1/;
		$conf_arr->[$i] =~ s/^DISABLE_TRIGGERS.*0/DISABLE_TRIGGERS\t1/;
		$conf_arr->[$i] =~ s/^(CLIENT_ENCODING.*)/#$1/;
		$conf_arr->[$i] =~ s/^(NLS_LANG.*)/#$1/;
		$conf_arr->[$i] =~ s/^#LONGREADLEN.*1047552/LONGREADLEN\t1047552/;
		$conf_arr->[$i] =~ s/^AUTODETECT_SPATIAL_TYPE.*0/AUTODETECT_SPATIAL_TYPE\t1/;
		$conf_arr->[$i] =~ s/^NO_LOB_LOCATOR.*/NO_LOB_LOCATOR\t0/;
		$conf_arr->[$i] =~ s/^USE_LOB_LOCATOR.*/USE_LOB_LOCATOR\t1/;
		$conf_arr->[$i] =~ s/^FTS_INDEX_ONLY.*0/FTS_INDEX_ONLY\t1/;
		$conf_arr->[$i] =~ s/^DISABLE_UNLOGGED.*0/DISABLE_UNLOGGED\t1/;
		$conf_arr->[$i] =~ s/^EMPTY_LOB_NULL.*0/EMPTY_LOB_NULL\t1/;
		$conf_arr->[$i] =~ s/^PG_NUMERIC_TYPE.*1/PG_NUMERIC_TYPE\t0/;
		$conf_arr->[$i] =~ s/^NULL_EQUAL_EMPTY.*0/NULL_EQUAL_EMPTY\t1/;
		if ($DSN) {
			$conf_arr->[$i] =~ s/^ORACLE_DSN.*/ORACLE_DSN\t$DSN/;
		}
		if ($DBUSER) {
			$conf_arr->[$i] =~ s/^ORACLE_USER.*/ORACLE_USER\t$DBUSER/;
		}
		if ($DBPWD) {
			$conf_arr->[$i] =~ s/^ORACLE_PWD.*/ORACLE_PWD\t$DBPWD/;
		}
	}
	map { s/$/\n/; } @$conf_arr;
}

__DATA__
#!/bin/sh
#-------------------------------------------------------------------------------
#
# Script used to load exported sql files into PostgreSQL in practical manner
# allowing you to chain and automatically import schema and data.
#
# Generated by Ora2Pg, the Oracle database Schema converter, version ORA2PG_VERSION
#
#-------------------------------------------------------------------------------

EXPORT_TYPE="TYPE,TABLE,PARTITION,VIEW,MVIEW,FUNCTION,PROCEDURE,SEQUENCE,TRIGGER,SYNONYM,DIRECTORY,DBLINK"
AUTORUN=0
NAMESPACE=.
NO_CONSTRAINTS=0
IMPORT_INDEXES_AFTER=0
DEBUG=0
IMPORT_SCHEMA=0
IMPORT_DATA=0
IMPORT_CONSTRAINTS=0
NO_DBCHECK=0


# Message functions
die() {
    echo "ERROR: $1" 1>&2
    exit 1
}

usage() {
    echo "usage: `basename $0` [options]"
    echo ""
    echo "Script used to load exported sql files into PostgreSQL in practical manner"
    echo "allowing you to chain and automatically import schema and data."
    echo ""
    echo "options:"
    echo "    -a             import data only"
    echo "    -b filename    SQL script to execute just after table creation to fix database schema"
    echo "    -d dbname      database name for import"
    echo "    -D             enable debug mode, will only show what will be done"
    echo "    -e encoding    database encoding to use at creation (default: UTF8)"
    echo "    -f             force no check of user and database existing and do not try to create them"
    echo "    -h hostname    hostname of the PostgreSQL server (default: unix socket)"
    echo "    -i             only load indexes, constraints and triggers"
    echo "    -I             do not try to load indexes, constraints and triggers"
    echo "    -j cores       number of connection to use to import data or indexes into PostgreSQL"
    echo "    -n schema      comma separated list of schema to create"
    echo "    -o username    owner of the database to create"
    echo "    -p port        listening port of the PostgreSQL server (default: 5432)"
    echo "    -P cores       number of tables to process at same time for data import"
    echo "    -s             import schema only, do not try to import data"
    echo "    -t export      comma separated list of export type to import (same as ora2pg)"
    echo "    -U username    username to connect to PostgreSQL (default: peer username)"
    echo "    -x             import indexes and constraints after data"
    echo "    -y             reply Yes to all questions for automatic import"
    echo
    echo "    -?             print help"
    echo
    exit $1
}

# Function to emulate Perl prompt function
confirm () {

    msg=$1
    if [ "$AUTORUN" != "0" ]; then
	true
    else
	    if [ -z "$msg" ]; then
		msg="Are you sure? [y/N/q]"
	    fi
	    # call with a prompt string or use a default
	    read -r -p "${msg} [y/N/q] " response
	    case $response in
		[yY][eE][sS]|[yY])
		    true
		    ;;
		[qQ][uU][iI][tT]|[qQ])
		    exit
		    ;;
		*)
		    false
		    ;;
	    esac
    fi
}

# Function used to import constraints and indexes
import_constraints () {
	if [ -r "$NAMESPACE/schema/tables/INDEXES_table.sql" ]; then
		if confirm "Would you like to import indexes from $NAMESPACE/schema/tables/INDEXES_table.sql?" ; then
			if [ -z "$IMPORT_JOBS" ]; then
				echo "Running: psql$DB_HOST$DB_PORT -U $DB_OWNER -d $DB_NAME -f $NAMESPACE/schema/tables/INDEXES_table.sql"
				if [ $DEBUG -eq 0 ]; then
					psql$DB_HOST$DB_PORT -U $DB_OWNER -d $DB_NAME -f $NAMESPACE/schema/tables/INDEXES_table.sql
					if [ $? -ne 0 ]; then
						die "无法导入索引。"
					fi
				fi
			else
				echo "Running: ora2pg -c config/ora2pg.conf -t LOAD -i $NAMESPACE/schema/tables/INDEXES_table.sql"
				if [ $DEBUG -eq 0 ]; then
					ora2pg$IMPORT_JOBS -c config/ora2pg.conf -t LOAD -i $NAMESPACE/schema/tables/INDEXES_table.sql
					if [ $? -ne 0 ]; then
						die "无法导入索引。"
					fi
				fi
			fi
		fi
	fi

	if [ -r "$NAMESPACE/schema/tables/CONSTRAINTS_table.sql" ]; then
		if confirm "Would you like to import constraints from $NAMESPACE/schema/tables/CONSTRAINTS_table.sql?" ; then
			if [ -z "$IMPORT_JOBS" ]; then
				echo "Running: psql$DB_HOST$DB_PORT -U $DB_OWNER -d $DB_NAME -f $NAMESPACE/schema/tables/CONSTRAINTS_table.sql"
				if [ $DEBUG -eq 0 ]; then
					psql$DB_HOST$DB_PORT -U $DB_OWNER -d $DB_NAME -f $NAMESPACE/schema/tables/CONSTRAINTS_table.sql
					if [ $? -ne 0 ]; then
						die "无法导入约束。"
					fi
				fi
			else
				echo "Running: ora2pg$IMPORT_JOBS -c config/ora2pg.conf -t LOAD -i $NAMESPACE/schema/tables/CONSTRAINTS_table.sql"
				if [ $DEBUG -eq 0 ]; then
					ora2pg$IMPORT_JOBS -c config/ora2pg.conf -t LOAD -i $NAMESPACE/schema/tables/CONSTRAINTS_table.sql
					if [ $? -ne 0 ]; then
						die "无法导入约束。"
					fi
				fi
			fi
		fi
	fi

	if [ -r "$NAMESPACE/schema/tables/FKEYS_table.sql" ]; then
		if confirm "Would you like to import foreign keys from $NAMESPACE/schema/tables/FKEYS_table.sql?" ; then
			if [ -z "$IMPORT_JOBS" ]; then
				echo "Running: psql$DB_HOST$DB_PORT -U $DB_OWNER -d $DB_NAME -f $NAMESPACE/schema/tables/FKEYS_table.sql"
				if [ $DEBUG -eq 0 ]; then
					psql$DB_HOST$DB_PORT -U $DB_OWNER -d $DB_NAME -f $NAMESPACE/schema/tables/FKEYS_table.sql
					if [ $? -ne 0 ]; then
						die "无法导入外键。"
					fi
				fi
			else
				echo "Running: ora2pg$IMPORT_JOBS -c config/ora2pg.conf -t LOAD -i $NAMESPACE/schema/tables/FKEYS_table.sql"
				if [ $DEBUG -eq 0 ]; then
					ora2pg$IMPORT_JOBS -c config/ora2pg.conf -t LOAD -i $NAMESPACE/schema/tables/FKEYS_table.sql
					if [ $? -ne 0 ]; then
						die "无法导入外键。"
					fi
				fi
			fi
		fi
	fi

	if [ -r "$NAMESPACE/schema/tables/FTS_INDEXES_table.sql" ]; then
		if confirm "Would you like to import FTS indexes from $NAMESPACE/schema/tables/FTS_INDEXES_table.sql?" ; then
			if [ -z "$IMPORT_JOBS" ]; then
				echo "Running: psql$DB_HOST$DB_PORT -U $DB_OWNER -d $DB_NAME -f $NAMESPACE/schema/tables/FTS_INDEXES_table.sql"
				if [ $DEBUG -eq 0 ]; then
					psql$DB_HOST$DB_PORT -U $DB_OWNER -d $DB_NAME -f $NAMESPACE/schema/tables/FTS_INDEXES_table.sql
					if [ $? -ne 0 ]; then
						die "无法导入 FTS 索引。"
					fi
				fi
			else
				echo "Running: ora2pg -c config/ora2pg.conf -t LOAD -i $NAMESPACE/schema/tables/FTS_INDEXES_table.sql"
				if [ $DEBUG -eq 0 ]; then
					ora2pg$IMPORT_JOBS -c config/ora2pg.conf -t LOAD -i $NAMESPACE/schema/tables/FTS_INDEXES_table.sql
					if [ $? -ne 0 ]; then
						die "无法导入 FTS 索引。"
					fi
				fi
			fi
		fi
	fi

	if [ -r "$NAMESPACE/schema/triggers/trigger.sql" ]; then
		if confirm "Would you like to import TRIGGER from $NAMESPACE/schema/triggers/trigger.sql?" ; then
			echo "Running: psql --single-transaction $DB_HOST$DB_PORT -U $DB_OWNER -d $DB_NAME -f $NAMESPACE/schema/triggers/trigger.sql"
			if [ $DEBUG -eq 0 ]; then
				psql --single-transaction $DB_HOST$DB_PORT -U $DB_OWNER -d $DB_NAME -f $NAMESPACE/schema/triggers/trigger.sql
				if [ $? -ne 0 ]; then
					die "an error occurs when importing file $NAMESPACE/schema/triggers/trigger.sql."
				fi
			fi
		fi
	fi
}

# Command line options
while getopts "b:d:e:h:j:l:n:o:p:P:t:U:aDfiIsyx?"  opt; do
    case "$opt" in
	a) IMPORT_DATA=1;;
	b) SQL_POST_SCRIPT=$OPTARG;;
        d) DB_NAME=$OPTARG;;
        D) DEBUG=1;;
        e) DB_ENCODING=" -E $OPTARG";;
	f) NO_DBCHECK=1;;
        h) DB_HOST=" -h $OPTARG";;
        i) IMPORT_CONSTRAINTS=1;;
        I) NO_CONSTRAINTS=1;;
        j) IMPORT_JOBS=" -j $OPTARG";;
        n) DB_SCHEMA=$OPTARG;;
        o) DB_OWNER=$OPTARG;;
        p) DB_PORT=" -p $OPTARG";;
        P) PARALLEL_TABLES=" -P $OPTARG";;
        s) IMPORT_SCHEMA=1;;
        t) EXPORT_TYPE=$OPTARG;;
        U) DB_USER=" -U $OPTARG";;
	x) IMPORT_INDEXES_AFTER=1;;
        y) AUTORUN=1;;
        "?") usage 1;;
        *) die "Unknown error while processing options";;
    esac
done

# Check if post tables import SQL script is readable
if [ ! -z "$SQL_POST_SCRIPT" ]; then
	if [ ! -r "$SQL_POST_SCRIPT" ]; then
		die "the SQL script $SQL_POST_SCRIPT is not readable."
	fi
fi

# A database name is mandatory
if [ -z "$DB_NAME" ]; then
	die "you must give a PostgreSQL database name (see -d option)."
fi

# A database owner is mandatory
if [ -z "$DB_OWNER" ]; then
	die "you must give a username to be used as owner of database (see -o option)."
fi

# Check if the project directory is readable
if [ ! -r "$NAMESPACE/schema/tables/table.sql" ]; then
	die "project directory '$NAMESPACE' is not valid or is not readable."
fi

# If constraints and indexes files are present propose to import these objects
if [ $IMPORT_CONSTRAINTS -eq 1 ]; then
	if confirm "Would you like to load indexes, constraints and triggers?" ; then
		import_constraints
	fi
	exit 0
fi

# When a PostgreSQL schema list is provided, create them
if [ $IMPORT_DATA -eq 0 ]; then
	is_superuser='f'
	if [ $NO_DBCHECK  -eq 0 ]; then
		# Create owner user
		user_exists=`psql -d $DB_NAME$DB_HOST$DB_PORT$DB_USER -Atc "select usename from pg_user where usename='$DB_OWNER';" 2>/dev/null`
		is_superuser=`psql -d $DB_NAME$DB_HOST$DB_PORT$DB_USER -Atc "select usesuper from pg_user where usename='$DB_OWNER';" 2>/dev/null`;
		if [ "a$user_exists" = "a" ]; then
			if confirm "Would you like to create the owner of the database $DB_OWNER?" ; then
				echo "Running: createuser$DB_HOST$DB_PORT$DB_USER --no-superuser --no-createrole --no-createdb $DB_OWNER"
				if [ $DEBUG -eq 0 ]; then
					createuser$DB_HOST$DB_PORT$DB_USER --no-superuser --no-createrole --no-createdb $DB_OWNER
					if [ $? -ne 0 ]; then
						die "can not create user $DB_OWNER."
					fi
				fi
			fi
		else
			echo "Database owner $DB_OWNER already exists, skipping creation."
		fi

		# Create database if required
		if [ "a$DB_ENCODING" = "a" ]; then
			DB_ENCODING=" -E UTF8"
		fi
		db_exists=`psql -d $DB_NAME$DB_HOST$DB_PORT$DB_USER -Atc "select datname from pg_database where datname='$DB_NAME';"`
		if [ "a$db_exists" = "a" ]; then
			if confirm "Would you like to create the database $DB_NAME?" ; then
				echo "Running: createdb$DB_HOST$DB_PORT$DB_USER$DB_ENCODING --owner $DB_OWNER $DB_NAME"
				if [ $DEBUG -eq 0 ]; then
					createdb$DB_HOST$DB_PORT$DB_USER$DB_ENCODING --owner $DB_OWNER $DB_NAME
					if [ $? -ne 0 ]; then
						die "can not create database $DB_NAME."
					fi
				fi
			fi
		else
			if confirm "Would you like to drop the database $DB_NAME before recreate it?" ; then
				echo "Running: dropdb$DB_HOST$DB_PORT$DB_USER $DB_NAME"
				if [ $DEBUG -eq 0 ]; then
					dropdb$DB_HOST$DB_PORT$DB_USER $DB_NAME
					if [ $? -ne 0 ]; then
						die "can not drop database $DB_NAME."
					fi
				fi
				echo "Running: createdb$DB_HOST$DB_PORT$DB_USER$DB_ENCODING --owner $DB_OWNER $DB_NAME"
				if [ $DEBUG -eq 0 ]; then
					createdb$DB_HOST$DB_PORT$DB_USER$DB_ENCODING --owner $DB_OWNER $DB_NAME
					if [ $? -ne 0 ]; then
						die "can not create database $DB_NAME."
					fi
				fi
			fi
		fi
	fi

	# When schema list is provided, create them
	if [ "a$DB_SCHEMA" != "a" ]; then
		nspace_list=''
		for enspace in $(echo $DB_SCHEMA | tr "," "\n")
		do
			lnspace=`echo $enspace | tr '[:upper:]' '[:lower:]'`
			if confirm "Would you like to create schema $lnspace in database $DB_NAME?" ; then
				echo "Running: psql$DB_HOST$DB_PORT -U $DB_OWNER -d $DB_NAME -c \"CREATE SCHEMA $lnspace;\""
				if [ $DEBUG -eq 0 ]; then
					psql$DB_HOST$DB_PORT -U $DB_OWNER -d $DB_NAME -c "CREATE SCHEMA $lnspace;"
					if [ $? -ne 0 ]; then
						die "can not create schema $DB_SCHEMA."
					fi
				fi
				nspace_list="$nspace_list$lnspace,"
			fi
		done
		# Change search path of the owner
		if [ "a$nspace_list" != "a" ]; then
			if confirm "Would you like to change search_path of the database owner?" ; then
				echo "Running: psql$DB_HOST$DB_PORT$DB_USER -d $DB_NAME -c \"ALTER ROLE $DB_OWNER SET search_path TO ${nspace_list}public;\""
				if [ $DEBUG -eq 0 ]; then
					psql$DB_HOST$DB_PORT$DB_USER -d $DB_NAME -c "ALTER ROLE $DB_OWNER SET search_path TO ${nspace_list}public;"
					if [ $? -ne 0 ]; then
						die "can not change search_path."
					fi
				fi
			fi
		fi
	fi

	# Then import all files from project directory
	for etype in $(echo $EXPORT_TYPE | tr "," "\n")
	do

		if [ $NO_CONSTRAINTS -eq 1 ] && [ $etype = "TRIGGER" ]; then
			continue
		fi

		if [ $etype = "GRANT" ] || [ $etype = "TABLESPACE" ]; then
			continue
		fi

		ltype=`echo $etype | tr '[:upper:]' '[:lower:]'`
		ltype=`echo $ltype | sed 's/y$/ie/'`
		ltype=`echo $ltype | sed 's/s$//'`
		if [ -r "$NAMESPACE/schema/${ltype}s/$ltype.sql" ]; then
			if confirm "Would you like to import $etype from $NAMESPACE/schema/${ltype}s/$ltype.sql?" ; then
				echo "Running: psql --single-transaction $DB_HOST$DB_PORT -U $DB_OWNER -d $DB_NAME -f $NAMESPACE/schema/${ltype}s/$ltype.sql"
				if [ $DEBUG -eq 0 ]; then
					psql --single-transaction $DB_HOST$DB_PORT -U $DB_OWNER -d $DB_NAME -f $NAMESPACE/schema/${ltype}s/$ltype.sql
					if [ $? -ne 0 ]; then
						die "an error occurs when importing file $NAMESPACE/schema/${ltype}s/$ltype.sql."
					fi
				fi
			fi
		fi
		if [ ! -z "$SQL_POST_SCRIPT" ] && [ $etype = "TABLE" ]; then
			if confirm "Would you like to execute SQL script $SQL_POST_SCRIPT?" ; then
				echo "Running: psql --single-transaction $DB_HOST$DB_PORT -U $DB_OWNER -d $DB_NAME -f $SQL_POST_SCRIPT"
				if [ $DEBUG -eq 0 ]; then
					psql --single-transaction $DB_HOST$DB_PORT -U $DB_OWNER -d $DB_NAME -f $SQL_POST_SCRIPT
					if [ $? -ne 0 ]; then
						die "an error occurs when importing file $SQL_POST_SCRIPT."
					fi
				fi
			fi
		fi
	done

	# If constraints and indexes files are present propose to import these objects
	if [ $NO_CONSTRAINTS -eq 0 ] && [ $IMPORT_INDEXES_AFTER -eq 0 ]; then
		if confirm "Would you like to process indexes and constraints before loading data?" ; then
			IMPORT_INDEXES_AFTER=0
			import_constraints
		else
			IMPORT_INDEXES_AFTER=1
		fi
	fi

	# When the database owner is not superuser use postgres instead
	q_user='postgres'
	if [ "$is_superuser" = "t" ]; then
		q_user=$DB_OWNER
	fi

	# Import objects that need superuser privilege: GRANT and TABLESPACE
	if [ -r "$NAMESPACE/schema/grants/grant.sql" ]; then
		if confirm "Would you like to import GRANT from $NAMESPACE/schema/grants/grant.sql?" ; then
			echo "Running: psql $DB_HOST$DB_PORT -U $q_user -d $DB_NAME -f $NAMESPACE/schema/grants/grant.sql"
			if [ $DEBUG -eq 0 ]; then
				psql $DB_HOST$DB_PORT -U $q_user -d $DB_NAME -f $NAMESPACE/schema/grants/grant.sql
				if [ $? -ne 0 ]; then
					die "an error occurs when importing file $NAMESPACE/schema/grants/grant.sql."
				fi
			fi
		fi
	fi
	if [ -r "$NAMESPACE/schema/tablespaces/tablespace.sql" ]; then
		if confirm "Would you like to import TABLESPACE from $NAMESPACE/schema/tablespaces/tablespace.sql?" ; then
			echo "Running: psql $DB_HOST$DB_PORT -U $q_user -d $DB_NAME -f $NAMESPACE/schema/tablespaces/tablespace.sql"
			if [ $DEBUG -eq 0 ]; then
				psql $DB_HOST$DB_PORT -U $q_user -d $DB_NAME -f $NAMESPACE/schema/tablespaces/tablespace.sql
				if [ $? -ne 0 ]; then
					die "an error occurs when importing file $NAMESPACE/schema/tablespaces/tablespace.sql."
				fi
			fi
		fi
	fi
fi


# Check if we must just import schema or proceed to data import too
if [ $IMPORT_SCHEMA -eq 0 ]; then
	# set the PostgreSQL datasource
	pgdsn_defined=`grep "^PG_DSN" config/ora2pg.conf | sed 's/.*dbi:Pg/dbi:Pg/'`
	if [ "a$pgdsn_defined" = "a" ]; then
		if [ "a$DB_HOST" != "a" ]; then
			pgdsn_defined="dbi:Pg:dbname=$DB_NAME;host=$DB_HOST"
		else
      #default to unix socket
      pgdsn_defined="dbi:Pg:dbname=$DB_NAME;"
    fi
		if [ "a$DB_PORT" != "a" ]; then
			pgdsn_defined="$pgdsn_defined;port=$DB_PORT"
		else
			pgdsn_defined="$pgdsn_defined;port=5432"
		fi
	fi

	# remove command line option from the DSN string
	pgdsn_defined=`echo "$pgdsn_defined" | sed 's/ -. //g'`

	# If data file is present propose to import data
	if [ -r "$NAMESPACE/data/data.sql" ]; then
		if confirm "Would you like to import data from $NAMESPACE/data/data.sql?" ; then
			echo "Running: psql$DB_HOST$DB_PORT -U $DB_OWNER -d $DB_NAME -f $NAMESPACE/data/data.sql"
			if [ $DEBUG -eq 0 ]; then
				psql$DB_HOST$DB_PORT -U $DB_OWNER -d $DB_NAME -f $NAMESPACE/data/data.sql
				if [ $? -ne 0 ]; then
					die "an error occurs when importing file $NAMESPACE/data/data.sql."
				fi
			fi
		fi
	else
		# Import data directly from PostgreSQL
		if confirm "Would you like to import data from Oracle database directly into PostgreSQL?" ; then
			echo "Running: ora2pg$IMPORT_JOBS$PARALLEL_TABLES -c config/ora2pg.conf -t DATA_ACTION --pg_dsn \"$pgdsn_defined\" --pg_user $DB_OWNER BLOB2LO"
			if [ $DEBUG -eq 0 ]; then
				ora2pg$IMPORT_JOBS$PARALLEL_TABLES -c config/ora2pg.conf -t DATA_ACTION --pg_dsn "$pgdsn_defined" --pg_user $DB_OWNER BLOB2LO
				if [ $? -ne 0 ]; then
					die "an error occurs when importing data."
				fi
			fi
		fi
	fi

	if [ $NO_CONSTRAINTS -eq 0 ] && [ $IMPORT_DATA -eq 0 ]; then
		# Import indexes and constraint after data
		if [ $IMPORT_INDEXES_AFTER -eq 1 ]; then
			import_constraints
		fi
	fi
fi

echo -e "\nOra2Pg ending"
exit 0

